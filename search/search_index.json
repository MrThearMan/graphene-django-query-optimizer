{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Graphene Django Query Optimizer pip install graphene-django-query-optimizer Documentation : https://mrthearman.github.io/graphene-django-query-optimizer/ Source Code : https://github.com/MrThearMan/graphene-django-query-optimizer/ Contributing : https://github.com/MrThearMan/graphene-django-query-optimizer/blob/main/CONTRIBUTING.md Solve the GraphQL N+1 problem in graphene-django applications just by changing a few imports, automatically adding the appropriate only , select_related , and prefetch_related method calls to your QuerySets to fetch only what you need. import graphene from example_project.app.models import Example from query_optimizer import DjangoObjectType, DjangoListField class ExampleType(DjangoObjectType): class Meta: model = Example class Query(graphene.ObjectType): all_examples = DjangoListField(ExampleType) schema = graphene.Schema(query=Query)","title":"Home"},{"location":"#graphene-django-query-optimizer","text":"pip install graphene-django-query-optimizer Documentation : https://mrthearman.github.io/graphene-django-query-optimizer/ Source Code : https://github.com/MrThearMan/graphene-django-query-optimizer/ Contributing : https://github.com/MrThearMan/graphene-django-query-optimizer/blob/main/CONTRIBUTING.md Solve the GraphQL N+1 problem in graphene-django applications just by changing a few imports, automatically adding the appropriate only , select_related , and prefetch_related method calls to your QuerySets to fetch only what you need. import graphene from example_project.app.models import Example from query_optimizer import DjangoObjectType, DjangoListField class ExampleType(DjangoObjectType): class Meta: model = Example class Query(graphene.ObjectType): all_examples = DjangoListField(ExampleType) schema = graphene.Schema(query=Query)","title":"Graphene Django Query Optimizer"},{"location":"custom/","text":"Custom fields GraphQL types can have non-model fields using custom resolvers. import graphene from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = graphene.String() def resolve_greeting(root: HousingCompany, info) -> str: return f\"Hello World!\" If the custom type requires fields from its related models to resolve, you have a few options. AnnotatedField This field can be used to add annotations to the queryset when the field is requested. import graphene from django.db.models import F, Value from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, AnnotatedField # new import class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = AnnotatedField(graphene.String, expression=Value(\"Hello \") + F(\"name\")) Note that only a single annotation can be added, however, you can use the aliases parameter to help with more complex annotations. import graphene from django.db.models import F, Value from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, AnnotatedField class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = AnnotatedField( graphene.String, expression=F(\"hello\") + F(\"name\"), aliases={\"hello\": Value(\"Hello \")}, # very complex! ) MultiField This field can be used to add multiple fields to the queryset when the field is requested. import graphene from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, MultiField # new import class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = MultiField(graphene.String, fields=[\"pk\", \"name\"]) def resolve_greeting(root: HousingCompany, info) -> str: return f\"Hello {root.name} ({root.pk})!\" Note that this can only be used for fields on the same model. ManuallyOptimizedField This is the most powerful custom field type, which allows defining a custom method to manually optimize the queryset when the field is requested. This allows for optimization strategies that are not possible with the other fields. Note: You shouldn't default to using this field, as it can break the optimization if you are not careful in considering other optimization already in the optimizer. import graphene from django.db.models import QuerySet from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, ManuallyOptimizedField # new import from query_optimizer.optimizer import QueryOptimizer # for type hinting class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany extra = ManuallyOptimizedField(graphene.String) @staticmethod def optimize_extra(queryset: QuerySet, optimizer: QueryOptimizer, **kwargs) -> QuerySet: # Do any optimizations here, returning the queryset. return queryset def resolve_extra(root: HousingCompany, info) -> str: # Still needs a resolver. return ... Note that this can only be used for fields on the same model. The field_name argument RelatedField , DjangoListField , DjangoConnectionField have a field_name argument that can be used to specify the field name in the queryset if it's different from the field name in the model. from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, DjangoListField # new import class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany developers_alt = DjangoListField(\"...\", field_name=\"developers\") This marks the field as being for the same relation as the field_name is on the model, and it will resolve the field as if it was that relation. This is achieved by using the Prefetch(\"developers\", qs, to_attr=\"developers_alt\") feature from Django.","title":"Custom Fields"},{"location":"custom/#custom-fields","text":"GraphQL types can have non-model fields using custom resolvers. import graphene from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = graphene.String() def resolve_greeting(root: HousingCompany, info) -> str: return f\"Hello World!\" If the custom type requires fields from its related models to resolve, you have a few options.","title":"Custom fields"},{"location":"custom/#annotatedfield","text":"This field can be used to add annotations to the queryset when the field is requested. import graphene from django.db.models import F, Value from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, AnnotatedField # new import class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = AnnotatedField(graphene.String, expression=Value(\"Hello \") + F(\"name\")) Note that only a single annotation can be added, however, you can use the aliases parameter to help with more complex annotations. import graphene from django.db.models import F, Value from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, AnnotatedField class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = AnnotatedField( graphene.String, expression=F(\"hello\") + F(\"name\"), aliases={\"hello\": Value(\"Hello \")}, # very complex! )","title":"AnnotatedField"},{"location":"custom/#multifield","text":"This field can be used to add multiple fields to the queryset when the field is requested. import graphene from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, MultiField # new import class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany greeting = MultiField(graphene.String, fields=[\"pk\", \"name\"]) def resolve_greeting(root: HousingCompany, info) -> str: return f\"Hello {root.name} ({root.pk})!\" Note that this can only be used for fields on the same model.","title":"MultiField"},{"location":"custom/#manuallyoptimizedfield","text":"This is the most powerful custom field type, which allows defining a custom method to manually optimize the queryset when the field is requested. This allows for optimization strategies that are not possible with the other fields. Note: You shouldn't default to using this field, as it can break the optimization if you are not careful in considering other optimization already in the optimizer. import graphene from django.db.models import QuerySet from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, ManuallyOptimizedField # new import from query_optimizer.optimizer import QueryOptimizer # for type hinting class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany extra = ManuallyOptimizedField(graphene.String) @staticmethod def optimize_extra(queryset: QuerySet, optimizer: QueryOptimizer, **kwargs) -> QuerySet: # Do any optimizations here, returning the queryset. return queryset def resolve_extra(root: HousingCompany, info) -> str: # Still needs a resolver. return ... Note that this can only be used for fields on the same model.","title":"ManuallyOptimizedField"},{"location":"custom/#the-field_name-argument","text":"RelatedField , DjangoListField , DjangoConnectionField have a field_name argument that can be used to specify the field name in the queryset if it's different from the field name in the model. from example_project.app.models import HousingCompany from query_optimizer import DjangoObjectType, DjangoListField # new import class HousingCompanyType(DjangoObjectType): class Meta: model = HousingCompany developers_alt = DjangoListField(\"...\", field_name=\"developers\") This marks the field as being for the same relation as the field_name is on the model, and it will resolve the field as if it was that relation. This is achieved by using the Prefetch(\"developers\", qs, to_attr=\"developers_alt\") feature from Django.","title":"The field_name argument"},{"location":"depth/","text":"Depth Limiting The optimize() function has builtin query depth limiting, which will allow a maximum of 10 select_related and prefetch_related actions per query by default. This should be a sensible limit that protects your API from misuse, but if you need to change it, it can be done on per resolver basis: import graphene from example_project.app.models import Apartment from query_optimizer import DjangoObjectType, optimize class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = graphene.List(ApartmentType) def resolve_all_apartments(root, info): return optimize(Apartment.objects.all(), info, max_complexity=4) # changed schema = graphene.Schema(query=Query) ...or per ObjectType basis for relay nodes and connections. import graphene from graphene import relay from example_project.app.models import Apartment from query_optimizer import DjangoObjectType class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) max_complexity = 4 # changed class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) You can also set the MAX_COMPLEXITY setting in your project's settings.py to set the value for all optimizers: GRAPHQL_QUERY_OPTIMIZER = { \"MAX_COMPLEXITY\": 15, }","title":"Depth Limiting"},{"location":"depth/#depth-limiting","text":"The optimize() function has builtin query depth limiting, which will allow a maximum of 10 select_related and prefetch_related actions per query by default. This should be a sensible limit that protects your API from misuse, but if you need to change it, it can be done on per resolver basis: import graphene from example_project.app.models import Apartment from query_optimizer import DjangoObjectType, optimize class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = graphene.List(ApartmentType) def resolve_all_apartments(root, info): return optimize(Apartment.objects.all(), info, max_complexity=4) # changed schema = graphene.Schema(query=Query) ...or per ObjectType basis for relay nodes and connections. import graphene from graphene import relay from example_project.app.models import Apartment from query_optimizer import DjangoObjectType class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) max_complexity = 4 # changed class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) You can also set the MAX_COMPLEXITY setting in your project's settings.py to set the value for all optimizers: GRAPHQL_QUERY_OPTIMIZER = { \"MAX_COMPLEXITY\": 15, }","title":"Depth Limiting"},{"location":"filtering/","text":"Filtering For adding additional filtering, optional dependency django-filter is required. import graphene from graphene import relay from example_project.app.models import Apartment from query_optimizer import DjangoObjectType, DjangoConnectionField class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) We can also implement a custom Filterset class to have more control over the filtering. from example_project.app.models import Apartment from django_filters import FilterSet class ApartmentFilterSet(FilterSet): # Custom filters can be added here class Meta: model = Apartment fields = [ \"completion_date\", \"street_address\", \"stair\", \"floor\", \"apartment_number\", ] These filters are for client side filtering. If you want to do server side filtering, for example to automatically remove rows the user doesn't have access to, we can use the filter_queryset method of the DjangoObjectType class. from django.db.models import QuerySet from query_optimizer import DjangoObjectType from query_optimizer.typing import GQLInfo class ApartmentType(DjangoObjectType): @classmethod def filter_queryset(cls, queryset: QuerySet, info: GQLInfo) -> QuerySet: # Add your custom filtering here return queryset.filter(...) The optimizer will find this method and use it automatically when this object type is used in a query. No additional queries are performed when using this method as opposed to overriding the get_queryset method itself.","title":"Filtering"},{"location":"filtering/#filtering","text":"For adding additional filtering, optional dependency django-filter is required. import graphene from graphene import relay from example_project.app.models import Apartment from query_optimizer import DjangoObjectType, DjangoConnectionField class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) We can also implement a custom Filterset class to have more control over the filtering. from example_project.app.models import Apartment from django_filters import FilterSet class ApartmentFilterSet(FilterSet): # Custom filters can be added here class Meta: model = Apartment fields = [ \"completion_date\", \"street_address\", \"stair\", \"floor\", \"apartment_number\", ] These filters are for client side filtering. If you want to do server side filtering, for example to automatically remove rows the user doesn't have access to, we can use the filter_queryset method of the DjangoObjectType class. from django.db.models import QuerySet from query_optimizer import DjangoObjectType from query_optimizer.typing import GQLInfo class ApartmentType(DjangoObjectType): @classmethod def filter_queryset(cls, queryset: QuerySet, info: GQLInfo) -> QuerySet: # Add your custom filtering here return queryset.filter(...) The optimizer will find this method and use it automatically when this object type is used in a query. No additional queries are performed when using this method as opposed to overriding the get_queryset method itself.","title":"Filtering"},{"location":"fragments/","text":"Fragments Fragment spreads Example query: query { allApartments { ...Shares } } fragment Shares on ApartmentType { sharesStart sharesEnd } Fragments spreads like these are optimized without any additional setup. Inline fragments Example query: query { allPeople { ... on DeveloperType { name housingCompanies { name } __typename } ... on PropertyManagerType { name housingCompanies { name } __typename } ... on OwnerType { name ownerships { percentage } __typename } } } Inline fragments like these can also be optimized. Here is how you would construct a resolver like this: import itertools import graphene from example_project.app.models import Developer, PropertyManager, Owner from query_optimizer import DjangoObjectType, optimize class DeveloperType(DjangoObjectType): class Meta: model = Developer class PropertyManagerType(DjangoObjectType): class Meta: model = PropertyManager class OwnerType(DjangoObjectType): class Meta: model = Owner class People(graphene.Union): class Meta: types = ( DeveloperType, PropertyManagerType, OwnerType, ) class Query(graphene.ObjectType): all_people = graphene.List(People) def resolve_all_people(root, info): developers = optimize(Developer.objects.all(), info) property_managers = optimize(PropertyManager.objects.all(), info) owners = optimize(Owner.objects.all(), info) return itertools.chain(developers, property_managers, owners) schema = graphene.Schema(query=Query)","title":"Fragments"},{"location":"fragments/#fragments","text":"","title":"Fragments"},{"location":"fragments/#fragment-spreads","text":"Example query: query { allApartments { ...Shares } } fragment Shares on ApartmentType { sharesStart sharesEnd } Fragments spreads like these are optimized without any additional setup.","title":"Fragment spreads"},{"location":"fragments/#inline-fragments","text":"Example query: query { allPeople { ... on DeveloperType { name housingCompanies { name } __typename } ... on PropertyManagerType { name housingCompanies { name } __typename } ... on OwnerType { name ownerships { percentage } __typename } } } Inline fragments like these can also be optimized. Here is how you would construct a resolver like this: import itertools import graphene from example_project.app.models import Developer, PropertyManager, Owner from query_optimizer import DjangoObjectType, optimize class DeveloperType(DjangoObjectType): class Meta: model = Developer class PropertyManagerType(DjangoObjectType): class Meta: model = PropertyManager class OwnerType(DjangoObjectType): class Meta: model = Owner class People(graphene.Union): class Meta: types = ( DeveloperType, PropertyManagerType, OwnerType, ) class Query(graphene.ObjectType): all_people = graphene.List(People) def resolve_all_people(root, info): developers = optimize(Developer.objects.all(), info) property_managers = optimize(PropertyManager.objects.all(), info) owners = optimize(Owner.objects.all(), info) return itertools.chain(developers, property_managers, owners) schema = graphene.Schema(query=Query)","title":"Inline fragments"},{"location":"quickstart/","text":"Quickstart The database schema these examples will be using can be seen here . Let's say we have defined a graphql schema like this: import graphene from graphene_django import DjangoObjectType, DjangoListField from example_project.app.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): # Imagine the rest of the types are also here, # and we omit it for brevity. all_apartments = DjangoListField(ApartmentType) schema = graphene.Schema(query=Query) Now, based on our database schema, we want to make a query like this: query { allApartments { streetAddress stair apartmentNumber sales { purchaseDate ownerships { percentage owner { name } } } } } As is, this query will result in: 1 query for all apartments 1 query or each sale 1 query for each ownership in each sale 1 query for each owner in each ownership in each sale Let's say that we have: a modest 20 apartments each apartment has 3 sales each sale has 2 ownerships In total, that's... 1 + (20 * 3) + (20 * 3 * 2) + (20 * 3 * 2 * 1) = 301 queries It's important to notice, that the amount of queries is proportional to the amount of records in our database, so the number of queries is only going to increase. This is called an N+1 problem . We are also over-fetching all fields on each model, and thus not taking advantage of GraphQLs schema at all. This is the issue this library hopes to solve. Shoutout to graphene-django-optimizer , which inspired this library. The library seem to no longer work in modern versions of graphene-django . Hopefully this library can replace it, while offering a cleaner API. We can optimize this query by simply using DjangoObjectType from query_optimizer instead of graphene_django import graphene from example_project.app.models import Apartment from query_optimizer import DjangoListField, DjangoObjectType class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = DjangoListField(ApartmentType) schema = graphene.Schema(query=Query) We could also use the optimize function to wrap a custom resolver queryset: import graphene from query_optimizer import DjangoObjectType, optimize # new import from example_project.app.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = graphene.List(ApartmentType) def resolve_all_apartments(root, info): return optimize(Apartment.objects.all(), info) # wrapped function schema = graphene.Schema(query=Query) That's it! With the following configuration, the same query will result in just 3 database queries, regardless of the number of database records. 1 query for all apartments 1 query for all sales in all apartments 1 query for all ownerships with their owners for each sale in each apartment Also, the optimization will only fetch the fields given in the GraphQL query, as the query intended. See technical details on how this works.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"The database schema these examples will be using can be seen here . Let's say we have defined a graphql schema like this: import graphene from graphene_django import DjangoObjectType, DjangoListField from example_project.app.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): # Imagine the rest of the types are also here, # and we omit it for brevity. all_apartments = DjangoListField(ApartmentType) schema = graphene.Schema(query=Query) Now, based on our database schema, we want to make a query like this: query { allApartments { streetAddress stair apartmentNumber sales { purchaseDate ownerships { percentage owner { name } } } } } As is, this query will result in: 1 query for all apartments 1 query or each sale 1 query for each ownership in each sale 1 query for each owner in each ownership in each sale Let's say that we have: a modest 20 apartments each apartment has 3 sales each sale has 2 ownerships In total, that's... 1 + (20 * 3) + (20 * 3 * 2) + (20 * 3 * 2 * 1) = 301 queries It's important to notice, that the amount of queries is proportional to the amount of records in our database, so the number of queries is only going to increase. This is called an N+1 problem . We are also over-fetching all fields on each model, and thus not taking advantage of GraphQLs schema at all. This is the issue this library hopes to solve. Shoutout to graphene-django-optimizer , which inspired this library. The library seem to no longer work in modern versions of graphene-django . Hopefully this library can replace it, while offering a cleaner API. We can optimize this query by simply using DjangoObjectType from query_optimizer instead of graphene_django import graphene from example_project.app.models import Apartment from query_optimizer import DjangoListField, DjangoObjectType class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = DjangoListField(ApartmentType) schema = graphene.Schema(query=Query) We could also use the optimize function to wrap a custom resolver queryset: import graphene from query_optimizer import DjangoObjectType, optimize # new import from example_project.app.models import Apartment class ApartmentType(DjangoObjectType): class Meta: model = Apartment class Query(graphene.ObjectType): all_apartments = graphene.List(ApartmentType) def resolve_all_apartments(root, info): return optimize(Apartment.objects.all(), info) # wrapped function schema = graphene.Schema(query=Query) That's it! With the following configuration, the same query will result in just 3 database queries, regardless of the number of database records. 1 query for all apartments 1 query for all sales in all apartments 1 query for all ownerships with their owners for each sale in each apartment Also, the optimization will only fetch the fields given in the GraphQL query, as the query intended. See technical details on how this works.","title":"Quickstart"},{"location":"relay/","text":"Relay The optimization will also work with Relay Nodes. Nodes Let's say we have the following node in out schema: import graphene from graphene import relay from graphene_django import DjangoObjectType from example_project.app.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) We can optimize this query by simply using DjangoObjectType from query_optimizer . import graphene from graphene import relay from example_project.app.models import Apartment from query_optimizer import DjangoObjectType class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) That's it! Connections Given the following connection in our schema: import graphene from graphene import relay from example_project.app.models import Apartment from graphene_django import DjangoObjectType, DjangoConnectionField class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) We can optimize this query by simply using DjangoObjectType and DjangoConnectionField from query_optimizer , like this: import graphene from graphene import relay from example_project.app.models import Apartment from query_optimizer import DjangoObjectType, DjangoConnectionField class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) That's it!","title":"Relay"},{"location":"relay/#relay","text":"The optimization will also work with Relay Nodes.","title":"Relay"},{"location":"relay/#nodes","text":"Let's say we have the following node in out schema: import graphene from graphene import relay from graphene_django import DjangoObjectType from example_project.app.models import Apartment class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) We can optimize this query by simply using DjangoObjectType from query_optimizer . import graphene from graphene import relay from example_project.app.models import Apartment from query_optimizer import DjangoObjectType class ApartmentNode(DjangoObjectType): class Meta: model = Apartment filter_fields = { \"street_address\": [\"exact\"], \"building__name\": [\"exact\"], } interfaces = (relay.Node,) class Query(graphene.ObjectType): apartment = relay.Node.Field(ApartmentNode) schema = graphene.Schema(query=Query) That's it!","title":"Nodes"},{"location":"relay/#connections","text":"Given the following connection in our schema: import graphene from graphene import relay from example_project.app.models import Apartment from graphene_django import DjangoObjectType, DjangoConnectionField class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) We can optimize this query by simply using DjangoObjectType and DjangoConnectionField from query_optimizer , like this: import graphene from graphene import relay from example_project.app.models import Apartment from query_optimizer import DjangoObjectType, DjangoConnectionField class ApartmentNode(DjangoObjectType): class Meta: model = Apartment interfaces = (relay.Node,) class Query(graphene.ObjectType): paged_apartments = DjangoConnectionField(ApartmentNode) schema = graphene.Schema(query=Query) That's it!","title":"Connections"},{"location":"settings/","text":"Settings Here are the available settings. Setting Type Default Description ALLOW_CONNECTION_AS_DEFAULT_NESTED_TO_MANY_FIELD bool False Should DjangoConnectionField be allowed to be generated for nested to-many fields if the ObjectType has a connection? If False (default), always use DjangoListField s. Doesn't prevent defining a DjangoConnectionField on the ObjectType manually. DEFAULT_FILTERSET_CLASS str \"\" The default filterset class to use. DISABLE_ONLY_FIELDS_OPTIMIZATION str False Set to True to disable optimizing fetched fields with queryset.only() . MAX_COMPLEXITY int 10 Default max number of select_related and prefetch_related joins optimizer is allowed to optimize. OPTIMIZER_MARK str \"_optimized\" Key used mark if a queryset has been optimized by the query optimizer. PREFETCH_COUNT_KEY str \"_optimizer_count\" Name used for annotating the prefetched queryset total count. PREFETCH_PARTITION_INDEX str \"_optimizer_partition_index\" Name used for aliasing the prefetched queryset partition index. PREFETCH_SLICE_START str \"_optimizer_slice_start\" Name used for aliasing the prefetched queryset slice start. PREFETCH_SLICE_STOP str \"_optimizer_slice_stop\" Name used for aliasing the prefetched queryset slice end. SKIP_OPTIMIZATION_ON_ERROR bool False If there is an unexpected error, should the optimizer skip optimization (True) or throw an error (False)? TOTAL_COUNT_FIELD str \"totalCount\" The field name to use for fetching total count in connection fields. Set them under the GRAPHQL_QUERY_OPTIMIZER key in your projects settings.py like this: GRAPHQL_QUERY_OPTIMIZER = { \"MAX_COMPLEXITY\": 10, }","title":"Settings"},{"location":"settings/#settings","text":"Here are the available settings. Setting Type Default Description ALLOW_CONNECTION_AS_DEFAULT_NESTED_TO_MANY_FIELD bool False Should DjangoConnectionField be allowed to be generated for nested to-many fields if the ObjectType has a connection? If False (default), always use DjangoListField s. Doesn't prevent defining a DjangoConnectionField on the ObjectType manually. DEFAULT_FILTERSET_CLASS str \"\" The default filterset class to use. DISABLE_ONLY_FIELDS_OPTIMIZATION str False Set to True to disable optimizing fetched fields with queryset.only() . MAX_COMPLEXITY int 10 Default max number of select_related and prefetch_related joins optimizer is allowed to optimize. OPTIMIZER_MARK str \"_optimized\" Key used mark if a queryset has been optimized by the query optimizer. PREFETCH_COUNT_KEY str \"_optimizer_count\" Name used for annotating the prefetched queryset total count. PREFETCH_PARTITION_INDEX str \"_optimizer_partition_index\" Name used for aliasing the prefetched queryset partition index. PREFETCH_SLICE_START str \"_optimizer_slice_start\" Name used for aliasing the prefetched queryset slice start. PREFETCH_SLICE_STOP str \"_optimizer_slice_stop\" Name used for aliasing the prefetched queryset slice end. SKIP_OPTIMIZATION_ON_ERROR bool False If there is an unexpected error, should the optimizer skip optimization (True) or throw an error (False)? TOTAL_COUNT_FIELD str \"totalCount\" The field name to use for fetching total count in connection fields. Set them under the GRAPHQL_QUERY_OPTIMIZER key in your projects settings.py like this: GRAPHQL_QUERY_OPTIMIZER = { \"MAX_COMPLEXITY\": 10, }","title":"Settings"},{"location":"technical/","text":"Technical details The optimizer uses the GraphQLResolveInfo and GraphQL AST to introspect the desired query, and construct queryset.only() , queryset.select_related() , and queryset.prefetch_related() statements for the resolver queryset. The queryset is then \"marked as optimized\" in the queryset hints (1) by setting a key defined by the OPTIMIZER_MARK setting. Queryset hints are designed to be used in multi-database routing, so this is a slightly hacky way to ensuring the mark is retained when the queryset is cloned. It is relatively safe since multi-database routers should accept the hints as **kwargs, and can ignore this extra hint.","title":"Technical Details"},{"location":"technical/#technical-details","text":"The optimizer uses the GraphQLResolveInfo and GraphQL AST to introspect the desired query, and construct queryset.only() , queryset.select_related() , and queryset.prefetch_related() statements for the resolver queryset. The queryset is then \"marked as optimized\" in the queryset hints (1) by setting a key defined by the OPTIMIZER_MARK setting. Queryset hints are designed to be used in multi-database routing, so this is a slightly hacky way to ensuring the mark is retained when the queryset is cloned. It is relatively safe since multi-database routers should accept the hints as **kwargs, and can ignore this extra hint.","title":"Technical details"}]}